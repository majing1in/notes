## 一、CPU高速缓存

![8](D:\notes\操作系统笔记\资源\8.jpg)

CPU高速缓存是位于CPU与内存之间的临时存储器，主要是为了解决CPU运行处理速度与内存读写速度不匹配的矛盾；

CPU在执行指令时需要从内存获取指令和所需的数据，但是CPU的速度远远大于内存速度，所以CPU直接从内存中取数据需要等待一段时间，造成资源的浪费并影响性能；

这时CPU引入了缓存机制，现在常见的CPU都采用的三级缓存结构，CPU缓存被分成了三个级别：L1、L2、L3，级别越小越接近CPU，所以速度也更快，同时也代表容量越小。

CPU往往需要重复相同的数据、指令，把这部份数据、指令放在CPU缓存中，CPU就不需要从内存中读取数据、指令，从而减少了响应时间，体现了局部性原理。

局部性原理：

- 时间局部性原理：如果某个数据被访问，那么不久的将来它可能再次被访问；
- 空间局部性原理：如果某个数据被访问，那么与它相邻的数据也可能很快被访问。

CPU缓存是由一组称之为缓存行的固定大小的数据块组成的，缓存行是缓存中可以分配的最小存储单位，通常是64字节；

但是引入了缓存，就需要考虑缓存一致性问题。

## 二、缓存一致性

CPU引入了高速缓存后提升了效率，但是同时也会引发缓存与主存不一致的问题。

对于单核CPU来说，通常有两种方式：

- 通写法(Write Through)：每次CPU修改了缓存内容，立即更新到内存，也就意味着每次 CPU 写共享数据，都会导致总线事务；
- 回写法(Write BACK)：每次CPU修改了缓存数据，不会立即更新到内存，而是等到某个合适的时机才会更新到内存中去。

对于多核 CPU 来说，情况会更为复杂，如下图：

![9](D:\notes\操作系统笔记\资源\9.jpg)

多核CPU存在多个一级缓存，为了保证缓存以及内存之间的一致性又引入了两种操作：

- 写失效：当一个 CPU 修改了数据，如果其他CPU有该数据，则通知其为无效；
- 写更新：当一个 CPU 修改了数据，如果其他CPU有该数据，则通知其更新数据。

另外在 CPU 层面，提供了两种解决方案：

- 总线锁：在多CPU情况下，某个CPU对共享变量操作时，在总线上发出一个`#LOCK`信号，总线把CPU和内存之间的通信锁住了，其它CPU不能操作该内存地址的数据；
- 缓存锁：降低了锁的粒度，基于缓存一致性协议来实现。

缓存一致性协议需要满足以下两种特性：

- 写传播(Write propagation)：一个处理器对于某个内存位置所做的写操作，对于其他处理器是可见的
- 写串行化(Write Serialization)：对同一内存单元的所有写操作都能串行化。即所有的处理器能以相同的次序看到这些写操作

对于写串行化：总线上任意时间只能出现一个 CPU 的写事件，多核并发的写事件会通过总线仲裁机制将其转换成串行化的的写事件序列。

对于写传播大致可以分为以下两种方式：

- 嗅探(Snooping )：广播机制，即要监听总线上的所有活动。
- 基于目录(Directory-based)：点对点，总线事件只会发给感兴趣的 CPU (借助 directory)。

缓存一致性协议通常指的是：MESI 协议.

## 三、MESI缓存一致性协议

## 四、MESI协议的问题与优化

## 五、JMM内存模型









