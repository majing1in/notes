## 一、CPU 指令集权限

指令集是 CPU 实现软件指挥硬件执行的媒介，具体来说每一条汇编语句都对应了一条 `CPU指令`，而非常非常多的 `CPU指令` 在一起，可以组成一个、甚至多个集合，指令的集合叫 `CPU指令集`。

同时 `CPU指令集` 有权限分级，硬件设备商直接提供硬件级别的支持，做法就是对 `CPU指令集`设置了权限，不同级别权限能使用的 `CPU指令集` 是有限的，以 Inter CPU 为例，Inter把 `CPU指令集` 操作的权限由高到低划为4级：

- ring 0
- ring 1
- ring 2
- ring 3

ring 0 权限最高，可以使用所有 `CPU指令集`，ring 3 权限最低，仅能使用常规 `CPU指令集`，不能使用操作硬件资源的 `CPU指令集`，比如 `IO` 读写、网卡访问、申请内存都不行，Linux系统仅采用ring 0 和 ring 3 这2个权限。

高情商

- ring 0被叫做内核态，完全在操作系统内核中运行
- ring 3被叫做用户态，在应用程序中运行

低情商

- 执行内核空间的代码，具有ring 0保护级别，有对硬件的所有操作权限，可以执行所有`CPU指令集`，访问任意地址的内存，在内核模式下的任何异常都是灾难性的，将会导致整台机器停机；
- 在用户模式下，具有ring 3保护级别，代码没有对硬件的直接控制权限，也不能直接访问地址的内存，程序是通过调用系统接口(System Call APIs)来达到访问硬件和内存，在这种保护模式下，即时程序发生崩溃也是可以恢复的，在电脑上大部分程序都是在，用户模式下运行的。

## 二、用户态与内核态

用户态与内核态的概念就是CPU指令集权限的区别，进程中要读写 `IO`，必然会用到 ring 0 级别的 `CPU指令集`，而此时CPU的指令集操作权限只有 ring 3，为了可以操作ring 0 级别的 `CPU指令集`， CPU切换指令集操作权限级别为 ring 0，CPU再执行相应的ring 0 级别的 `CPU指令集`（内核代码），执行的内核代码会使用当前进程的内核栈。

PS：每个进程都有两个栈，分别是用户栈与内核栈，对应用户态与内核态的使用。

## 三、用户态与内核态的空间

操作系统对用户态与内核态也做了限制，每个进程创建都会分配「虚拟空间地址」。

以Linux32位操作系统为例，它的寻址空间范围是 `4G`（2的32次方），而操作系统会把虚拟控制地址划分为两部分，一部分为内核空间，另一部分为用户空间，高位的 `1G`（从虚拟地址 0xC0000000 到 0xFFFFFFFF）由内核使用，而低位的 `3G`（从虚拟地址 0x00000000 到 0xBFFFFFFF）由各个进程使用。

![11](D:\notes\操作系统笔记\资源\11.jpg)

- 用户态：只能操作 `0-3G` 范围的低位虚拟空间地址；
- 内核态：`0-4G` 范围的虚拟空间地址都可以操作，尤其是对 `3-4G` 范围的高位虚拟空间地址必须由内核态去操作；
- 补充：`3G-4G` 部分大家是共享的（指所有进程的内核态逻辑地址是共享同一块内存地址），是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据.

每个进程的 `4G` 虚拟空间地址，高位 `1G` 都是一样的，即内核空间，只有剩余的 `3G` 才归进程自己使用，换句话说就是， 高位 `1G` 的内核空间是被所有进程共享的。

最后做个小结，我们通过指令集权限区分用户态和内核态，还限制了内存资源的使用，操作系统为用户态与内核态划分了两块内存空间，给它们对应的指令集使用。

## 四、用户态与内核态的切换

切换大致流程：

- 保留用户态现场（上下文、寄存器、用户栈等）；
- 复制用户态参数，用户栈切到内核栈，进入内核态；
- 额外的检查（因为内核代码对用户不信任）；
- 执行内核态代码；
- 复制内核态代码执行结果，回到用户态；
- 恢复用户态现场（上下文、寄存器、用户栈等）

实际上操作系统会比上述的更复杂，这里只是个大概，我们可以发现一次切换经历了「用户态 -> 内核态 -> 用户态」。

用户态要主动切换到内核态，那必须要有入口才行，实际上内核态是提供了统一的入口，下面是Linux整体架构图：

![12](D:\notes\操作系统笔记\资源\12.jpg)

系统调用将Linux整个体系分为用户态和内核态，为了使应用程序访问到内核的资源，如CPU、内存、I/O，内核必须提供一组通用的访问接口，这些接口就叫系统调用。

库函数就是屏蔽这些复杂的底层实现细节，减轻程序员的负担，从而更加关注上层的逻辑实现，它对系统调用进行封装，提供简单的基本接口给程序员。

什么情况会导致用户态到内核态切换：

- 系统调用：用户态进程主动切换到内核态的方式，用户态进程通过系统调用向操作系统申请资源完成工作，例如 fork（）就是一个创建新进程的系统调用，系统调用的机制核心使用了操作系统为用户特别开放的一个中断来实现，如Linux 的 int 80h 中断，也可以称为软中断
- 异常：当CPU在执行用户态的进程时，发生了一些没有预知的异常，这时当前运行进程会切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常
- 中断：当CPU在执行用户态的进程时，外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令，转到与中断信号对应的处理程序去执行，也就是切换到了内核态。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等。







































